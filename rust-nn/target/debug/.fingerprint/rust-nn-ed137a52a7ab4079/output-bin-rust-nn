{"$message_type":"diagnostic","message":"cannot find type `Lazy` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":1155,"byte_end":1159,"line_start":63,"line_end":63,"column_start":24,"column_end":28,"is_primary":true,"text":[{"text":"static GLOBAL_CONTEXT: Lazy<Mutex<TensorContext>> = Lazy::new(|| {","highlight_start":24,"highlight_end":28}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find type `Lazy` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:63:24\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m63\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mstatic GLOBAL_CONTEXT: Lazy<Mutex<TensorContext>> = Lazy::new(|| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `Lazy`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":1184,"byte_end":1188,"line_start":63,"line_end":63,"column_start":53,"column_end":57,"is_primary":true,"text":[{"text":"static GLOBAL_CONTEXT: Lazy<Mutex<TensorContext>> = Lazy::new(|| {","highlight_start":53,"highlight_end":57}],"label":"use of undeclared type `Lazy`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: use of undeclared type `Lazy`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:63:53\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m63\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mstatic GLOBAL_CONTEXT: Lazy<Mutex<TensorContext>> = Lazy::new(|| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared type `Lazy`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":5126,"byte_end":5145,"line_start":208,"line_end":208,"column_start":39,"column_end":58,"is_primary":false,"text":[{"text":"                Tensor::with_shape_f32(new_data, vec![1])","highlight_start":39,"highlight_end":58}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":5104,"byte_end":5126,"line_start":208,"line_end":208,"column_start":17,"column_end":39,"is_primary":true,"text":[{"text":"                Tensor::with_shape_f32(new_data, vec![1])","highlight_start":17,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":5126,"byte_end":5145,"line_start":208,"line_end":208,"column_start":39,"column_end":58,"is_primary":true,"text":[{"text":"                Tensor::with_shape_f32(new_data, vec![1])","highlight_start":39,"highlight_end":58}],"label":null,"suggested_replacement":"(new_data, vec![1], /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:208:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m208\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                Tensor::with_shape_f32(new_data, vec![1])\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m208\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(new_data, vec![1], /* Option<Vec<Tensor>> */)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":6121,"byte_end":6142,"line_start":233,"line_end":233,"column_start":51,"column_end":72,"is_primary":false,"text":[{"text":"                            Tensor::with_shape_f32(new_data, new_shape)","highlight_start":51,"highlight_end":72}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":6099,"byte_end":6121,"line_start":233,"line_end":233,"column_start":29,"column_end":51,"is_primary":true,"text":[{"text":"                            Tensor::with_shape_f32(new_data, new_shape)","highlight_start":29,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":6121,"byte_end":6142,"line_start":233,"line_end":233,"column_start":51,"column_end":72,"is_primary":true,"text":[{"text":"                            Tensor::with_shape_f32(new_data, new_shape)","highlight_start":51,"highlight_end":72}],"label":null,"suggested_replacement":"(new_data, new_shape, /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:233:29\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m233\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\u001b[0m                   Tensor::with_shape_f32(new_data, new_shape)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m---------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m233\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                            Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(new_data, new_shape, /* Option<Vec<Tensor>> */)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                                   \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":8023,"byte_end":8044,"line_start":268,"line_end":268,"column_start":51,"column_end":72,"is_primary":false,"text":[{"text":"                            Tensor::with_shape_f32(new_data, new_shape)","highlight_start":51,"highlight_end":72}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":8001,"byte_end":8023,"line_start":268,"line_end":268,"column_start":29,"column_end":51,"is_primary":true,"text":[{"text":"                            Tensor::with_shape_f32(new_data, new_shape)","highlight_start":29,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":8023,"byte_end":8044,"line_start":268,"line_end":268,"column_start":51,"column_end":72,"is_primary":true,"text":[{"text":"                            Tensor::with_shape_f32(new_data, new_shape)","highlight_start":51,"highlight_end":72}],"label":null,"suggested_replacement":"(new_data, new_shape, /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:268:29\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m268\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\u001b[0m                   Tensor::with_shape_f32(new_data, new_shape)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m---------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m268\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                            Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(new_data, new_shape, /* Option<Vec<Tensor>> */)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                                   \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":9243,"byte_end":9269,"line_start":300,"line_end":300,"column_start":47,"column_end":73,"is_primary":false,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape1.clone())","highlight_start":47,"highlight_end":73}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13839,"byte_end":13874,"line_start":432,"line_end":432,"column_start":1,"column_end":36,"is_primary":false,"text":[{"text":"impl_tensor_op!(Add, add, +, \"add\");","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\main.rs","byte_start":9221,"byte_end":9243,"line_start":300,"line_end":300,"column_start":25,"column_end":47,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape1.clone())","highlight_start":25,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13839,"byte_end":13874,"line_start":432,"line_end":432,"column_start":1,"column_end":36,"is_primary":false,"text":[{"text":"impl_tensor_op!(Add, add, +, \"add\");","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":9243,"byte_end":9269,"line_start":300,"line_end":300,"column_start":47,"column_end":73,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape1.clone())","highlight_start":47,"highlight_end":73}],"label":null,"suggested_replacement":"(new_data, shape1.clone(), /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":{"span":{"file_name":"src\\main.rs","byte_start":13839,"byte_end":13874,"line_start":432,"line_end":432,"column_start":1,"column_end":36,"is_primary":false,"text":[{"text":"impl_tensor_op!(Add, add, +, \"add\");","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:300:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m300\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        Tensor::with_shape_f32(new_data, shape1.clone())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m432\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_tensor_op!(Add, add, +, \"add\");\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_tensor_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m300\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(new_data, shape1.clone(), /* Option<Vec<Tensor>> */)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":10661,"byte_end":10686,"line_start":337,"line_end":337,"column_start":47,"column_end":72,"is_primary":false,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13839,"byte_end":13874,"line_start":432,"line_end":432,"column_start":1,"column_end":36,"is_primary":false,"text":[{"text":"impl_tensor_op!(Add, add, +, \"add\");","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\main.rs","byte_start":10639,"byte_end":10661,"line_start":337,"line_end":337,"column_start":25,"column_end":47,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":25,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13839,"byte_end":13874,"line_start":432,"line_end":432,"column_start":1,"column_end":36,"is_primary":false,"text":[{"text":"impl_tensor_op!(Add, add, +, \"add\");","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":10661,"byte_end":10686,"line_start":337,"line_end":337,"column_start":47,"column_end":72,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":null,"suggested_replacement":"(new_data, shape.clone(), /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":{"span":{"file_name":"src\\main.rs","byte_start":13839,"byte_end":13874,"line_start":432,"line_end":432,"column_start":1,"column_end":36,"is_primary":false,"text":[{"text":"impl_tensor_op!(Add, add, +, \"add\");","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:337:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m337\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        Tensor::with_shape_f32(new_data, shape.clone())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m432\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_tensor_op!(Add, add, +, \"add\");\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_tensor_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m337\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(new_data, shape.clone(), /* Option<Vec<Tensor>> */)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":11346,"byte_end":11371,"line_start":354,"line_end":354,"column_start":47,"column_end":72,"is_primary":false,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13839,"byte_end":13874,"line_start":432,"line_end":432,"column_start":1,"column_end":36,"is_primary":false,"text":[{"text":"impl_tensor_op!(Add, add, +, \"add\");","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\main.rs","byte_start":11324,"byte_end":11346,"line_start":354,"line_end":354,"column_start":25,"column_end":47,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":25,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13839,"byte_end":13874,"line_start":432,"line_end":432,"column_start":1,"column_end":36,"is_primary":false,"text":[{"text":"impl_tensor_op!(Add, add, +, \"add\");","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":11346,"byte_end":11371,"line_start":354,"line_end":354,"column_start":47,"column_end":72,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":null,"suggested_replacement":"(new_data, shape.clone(), /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":{"span":{"file_name":"src\\main.rs","byte_start":13839,"byte_end":13874,"line_start":432,"line_end":432,"column_start":1,"column_end":36,"is_primary":false,"text":[{"text":"impl_tensor_op!(Add, add, +, \"add\");","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:354:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m354\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        Tensor::with_shape_f32(new_data, shape.clone())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m432\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_tensor_op!(Add, add, +, \"add\");\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_tensor_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m354\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(new_data, shape.clone(), /* Option<Vec<Tensor>> */)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":12447,"byte_end":12472,"line_start":388,"line_end":388,"column_start":47,"column_end":72,"is_primary":false,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13839,"byte_end":13874,"line_start":432,"line_end":432,"column_start":1,"column_end":36,"is_primary":false,"text":[{"text":"impl_tensor_op!(Add, add, +, \"add\");","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\main.rs","byte_start":12425,"byte_end":12447,"line_start":388,"line_end":388,"column_start":25,"column_end":47,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":25,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13839,"byte_end":13874,"line_start":432,"line_end":432,"column_start":1,"column_end":36,"is_primary":false,"text":[{"text":"impl_tensor_op!(Add, add, +, \"add\");","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":12447,"byte_end":12472,"line_start":388,"line_end":388,"column_start":47,"column_end":72,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":null,"suggested_replacement":"(new_data, shape.clone(), /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":{"span":{"file_name":"src\\main.rs","byte_start":13839,"byte_end":13874,"line_start":432,"line_end":432,"column_start":1,"column_end":36,"is_primary":false,"text":[{"text":"impl_tensor_op!(Add, add, +, \"add\");","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:388:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m388\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        Tensor::with_shape_f32(new_data, shape.clone())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m432\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_tensor_op!(Add, add, +, \"add\");\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_tensor_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m388\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(new_data, shape.clone(), /* Option<Vec<Tensor>> */)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":13134,"byte_end":13159,"line_start":405,"line_end":405,"column_start":47,"column_end":72,"is_primary":false,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13839,"byte_end":13874,"line_start":432,"line_end":432,"column_start":1,"column_end":36,"is_primary":false,"text":[{"text":"impl_tensor_op!(Add, add, +, \"add\");","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\main.rs","byte_start":13112,"byte_end":13134,"line_start":405,"line_end":405,"column_start":25,"column_end":47,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":25,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13839,"byte_end":13874,"line_start":432,"line_end":432,"column_start":1,"column_end":36,"is_primary":false,"text":[{"text":"impl_tensor_op!(Add, add, +, \"add\");","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":13134,"byte_end":13159,"line_start":405,"line_end":405,"column_start":47,"column_end":72,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":null,"suggested_replacement":"(new_data, shape.clone(), /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":{"span":{"file_name":"src\\main.rs","byte_start":13839,"byte_end":13874,"line_start":432,"line_end":432,"column_start":1,"column_end":36,"is_primary":false,"text":[{"text":"impl_tensor_op!(Add, add, +, \"add\");","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:405:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m405\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        Tensor::with_shape_f32(new_data, shape.clone())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m432\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_tensor_op!(Add, add, +, \"add\");\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_tensor_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m405\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(new_data, shape.clone(), /* Option<Vec<Tensor>> */)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":9243,"byte_end":9269,"line_start":300,"line_end":300,"column_start":47,"column_end":73,"is_primary":false,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape1.clone())","highlight_start":47,"highlight_end":73}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13876,"byte_end":13916,"line_start":433,"line_end":433,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Sub, sub, -, \"subtract\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\main.rs","byte_start":9221,"byte_end":9243,"line_start":300,"line_end":300,"column_start":25,"column_end":47,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape1.clone())","highlight_start":25,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13876,"byte_end":13916,"line_start":433,"line_end":433,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Sub, sub, -, \"subtract\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":9243,"byte_end":9269,"line_start":300,"line_end":300,"column_start":47,"column_end":73,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape1.clone())","highlight_start":47,"highlight_end":73}],"label":null,"suggested_replacement":"(new_data, shape1.clone(), /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":{"span":{"file_name":"src\\main.rs","byte_start":13876,"byte_end":13916,"line_start":433,"line_end":433,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Sub, sub, -, \"subtract\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:300:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m300\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        Tensor::with_shape_f32(new_data, shape1.clone())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m433\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_tensor_op!(Sub, sub, -, \"subtract\");\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_tensor_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m300\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(new_data, shape1.clone(), /* Option<Vec<Tensor>> */)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":10661,"byte_end":10686,"line_start":337,"line_end":337,"column_start":47,"column_end":72,"is_primary":false,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13876,"byte_end":13916,"line_start":433,"line_end":433,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Sub, sub, -, \"subtract\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\main.rs","byte_start":10639,"byte_end":10661,"line_start":337,"line_end":337,"column_start":25,"column_end":47,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":25,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13876,"byte_end":13916,"line_start":433,"line_end":433,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Sub, sub, -, \"subtract\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":10661,"byte_end":10686,"line_start":337,"line_end":337,"column_start":47,"column_end":72,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":null,"suggested_replacement":"(new_data, shape.clone(), /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":{"span":{"file_name":"src\\main.rs","byte_start":13876,"byte_end":13916,"line_start":433,"line_end":433,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Sub, sub, -, \"subtract\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:337:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m337\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        Tensor::with_shape_f32(new_data, shape.clone())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m433\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_tensor_op!(Sub, sub, -, \"subtract\");\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_tensor_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m337\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(new_data, shape.clone(), /* Option<Vec<Tensor>> */)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":11346,"byte_end":11371,"line_start":354,"line_end":354,"column_start":47,"column_end":72,"is_primary":false,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13876,"byte_end":13916,"line_start":433,"line_end":433,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Sub, sub, -, \"subtract\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\main.rs","byte_start":11324,"byte_end":11346,"line_start":354,"line_end":354,"column_start":25,"column_end":47,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":25,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13876,"byte_end":13916,"line_start":433,"line_end":433,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Sub, sub, -, \"subtract\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":11346,"byte_end":11371,"line_start":354,"line_end":354,"column_start":47,"column_end":72,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":null,"suggested_replacement":"(new_data, shape.clone(), /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":{"span":{"file_name":"src\\main.rs","byte_start":13876,"byte_end":13916,"line_start":433,"line_end":433,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Sub, sub, -, \"subtract\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:354:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m354\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        Tensor::with_shape_f32(new_data, shape.clone())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m433\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_tensor_op!(Sub, sub, -, \"subtract\");\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_tensor_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m354\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(new_data, shape.clone(), /* Option<Vec<Tensor>> */)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":12447,"byte_end":12472,"line_start":388,"line_end":388,"column_start":47,"column_end":72,"is_primary":false,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13876,"byte_end":13916,"line_start":433,"line_end":433,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Sub, sub, -, \"subtract\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\main.rs","byte_start":12425,"byte_end":12447,"line_start":388,"line_end":388,"column_start":25,"column_end":47,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":25,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13876,"byte_end":13916,"line_start":433,"line_end":433,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Sub, sub, -, \"subtract\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":12447,"byte_end":12472,"line_start":388,"line_end":388,"column_start":47,"column_end":72,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":null,"suggested_replacement":"(new_data, shape.clone(), /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":{"span":{"file_name":"src\\main.rs","byte_start":13876,"byte_end":13916,"line_start":433,"line_end":433,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Sub, sub, -, \"subtract\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:388:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m388\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        Tensor::with_shape_f32(new_data, shape.clone())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m433\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_tensor_op!(Sub, sub, -, \"subtract\");\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_tensor_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m388\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(new_data, shape.clone(), /* Option<Vec<Tensor>> */)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":13134,"byte_end":13159,"line_start":405,"line_end":405,"column_start":47,"column_end":72,"is_primary":false,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13876,"byte_end":13916,"line_start":433,"line_end":433,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Sub, sub, -, \"subtract\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\main.rs","byte_start":13112,"byte_end":13134,"line_start":405,"line_end":405,"column_start":25,"column_end":47,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":25,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13876,"byte_end":13916,"line_start":433,"line_end":433,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Sub, sub, -, \"subtract\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":13134,"byte_end":13159,"line_start":405,"line_end":405,"column_start":47,"column_end":72,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":null,"suggested_replacement":"(new_data, shape.clone(), /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":{"span":{"file_name":"src\\main.rs","byte_start":13876,"byte_end":13916,"line_start":433,"line_end":433,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Sub, sub, -, \"subtract\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:405:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m405\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        Tensor::with_shape_f32(new_data, shape.clone())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m433\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_tensor_op!(Sub, sub, -, \"subtract\");\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_tensor_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m405\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(new_data, shape.clone(), /* Option<Vec<Tensor>> */)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":9243,"byte_end":9269,"line_start":300,"line_end":300,"column_start":47,"column_end":73,"is_primary":false,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape1.clone())","highlight_start":47,"highlight_end":73}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13918,"byte_end":13958,"line_start":434,"line_end":434,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Mul, mul, *, \"multiply\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\main.rs","byte_start":9221,"byte_end":9243,"line_start":300,"line_end":300,"column_start":25,"column_end":47,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape1.clone())","highlight_start":25,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13918,"byte_end":13958,"line_start":434,"line_end":434,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Mul, mul, *, \"multiply\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":9243,"byte_end":9269,"line_start":300,"line_end":300,"column_start":47,"column_end":73,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape1.clone())","highlight_start":47,"highlight_end":73}],"label":null,"suggested_replacement":"(new_data, shape1.clone(), /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":{"span":{"file_name":"src\\main.rs","byte_start":13918,"byte_end":13958,"line_start":434,"line_end":434,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Mul, mul, *, \"multiply\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:300:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m300\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        Tensor::with_shape_f32(new_data, shape1.clone())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m434\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_tensor_op!(Mul, mul, *, \"multiply\");\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_tensor_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m300\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(new_data, shape1.clone(), /* Option<Vec<Tensor>> */)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":10661,"byte_end":10686,"line_start":337,"line_end":337,"column_start":47,"column_end":72,"is_primary":false,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13918,"byte_end":13958,"line_start":434,"line_end":434,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Mul, mul, *, \"multiply\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\main.rs","byte_start":10639,"byte_end":10661,"line_start":337,"line_end":337,"column_start":25,"column_end":47,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":25,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13918,"byte_end":13958,"line_start":434,"line_end":434,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Mul, mul, *, \"multiply\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":10661,"byte_end":10686,"line_start":337,"line_end":337,"column_start":47,"column_end":72,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":null,"suggested_replacement":"(new_data, shape.clone(), /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":{"span":{"file_name":"src\\main.rs","byte_start":13918,"byte_end":13958,"line_start":434,"line_end":434,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Mul, mul, *, \"multiply\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:337:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m337\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        Tensor::with_shape_f32(new_data, shape.clone())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m434\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_tensor_op!(Mul, mul, *, \"multiply\");\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_tensor_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m337\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(new_data, shape.clone(), /* Option<Vec<Tensor>> */)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":11346,"byte_end":11371,"line_start":354,"line_end":354,"column_start":47,"column_end":72,"is_primary":false,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13918,"byte_end":13958,"line_start":434,"line_end":434,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Mul, mul, *, \"multiply\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\main.rs","byte_start":11324,"byte_end":11346,"line_start":354,"line_end":354,"column_start":25,"column_end":47,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":25,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13918,"byte_end":13958,"line_start":434,"line_end":434,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Mul, mul, *, \"multiply\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":11346,"byte_end":11371,"line_start":354,"line_end":354,"column_start":47,"column_end":72,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":null,"suggested_replacement":"(new_data, shape.clone(), /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":{"span":{"file_name":"src\\main.rs","byte_start":13918,"byte_end":13958,"line_start":434,"line_end":434,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Mul, mul, *, \"multiply\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:354:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m354\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        Tensor::with_shape_f32(new_data, shape.clone())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m434\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_tensor_op!(Mul, mul, *, \"multiply\");\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_tensor_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m354\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(new_data, shape.clone(), /* Option<Vec<Tensor>> */)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":12447,"byte_end":12472,"line_start":388,"line_end":388,"column_start":47,"column_end":72,"is_primary":false,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13918,"byte_end":13958,"line_start":434,"line_end":434,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Mul, mul, *, \"multiply\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\main.rs","byte_start":12425,"byte_end":12447,"line_start":388,"line_end":388,"column_start":25,"column_end":47,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":25,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13918,"byte_end":13958,"line_start":434,"line_end":434,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Mul, mul, *, \"multiply\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":12447,"byte_end":12472,"line_start":388,"line_end":388,"column_start":47,"column_end":72,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":null,"suggested_replacement":"(new_data, shape.clone(), /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":{"span":{"file_name":"src\\main.rs","byte_start":13918,"byte_end":13958,"line_start":434,"line_end":434,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Mul, mul, *, \"multiply\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:388:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m388\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        Tensor::with_shape_f32(new_data, shape.clone())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m434\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_tensor_op!(Mul, mul, *, \"multiply\");\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_tensor_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m388\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(new_data, shape.clone(), /* Option<Vec<Tensor>> */)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":13134,"byte_end":13159,"line_start":405,"line_end":405,"column_start":47,"column_end":72,"is_primary":false,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13918,"byte_end":13958,"line_start":434,"line_end":434,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Mul, mul, *, \"multiply\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\main.rs","byte_start":13112,"byte_end":13134,"line_start":405,"line_end":405,"column_start":25,"column_end":47,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":25,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13918,"byte_end":13958,"line_start":434,"line_end":434,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Mul, mul, *, \"multiply\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":13134,"byte_end":13159,"line_start":405,"line_end":405,"column_start":47,"column_end":72,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":null,"suggested_replacement":"(new_data, shape.clone(), /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":{"span":{"file_name":"src\\main.rs","byte_start":13918,"byte_end":13958,"line_start":434,"line_end":434,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"impl_tensor_op!(Mul, mul, *, \"multiply\");","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:405:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m405\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        Tensor::with_shape_f32(new_data, shape.clone())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m434\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_tensor_op!(Mul, mul, *, \"multiply\");\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_tensor_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m405\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(new_data, shape.clone(), /* Option<Vec<Tensor>> */)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":9243,"byte_end":9269,"line_start":300,"line_end":300,"column_start":47,"column_end":73,"is_primary":false,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape1.clone())","highlight_start":47,"highlight_end":73}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13960,"byte_end":13998,"line_start":435,"line_end":435,"column_start":1,"column_end":39,"is_primary":false,"text":[{"text":"impl_tensor_op!(Div, div, /, \"divide\");","highlight_start":1,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\main.rs","byte_start":9221,"byte_end":9243,"line_start":300,"line_end":300,"column_start":25,"column_end":47,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape1.clone())","highlight_start":25,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13960,"byte_end":13998,"line_start":435,"line_end":435,"column_start":1,"column_end":39,"is_primary":false,"text":[{"text":"impl_tensor_op!(Div, div, /, \"divide\");","highlight_start":1,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":9243,"byte_end":9269,"line_start":300,"line_end":300,"column_start":47,"column_end":73,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape1.clone())","highlight_start":47,"highlight_end":73}],"label":null,"suggested_replacement":"(new_data, shape1.clone(), /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":{"span":{"file_name":"src\\main.rs","byte_start":13960,"byte_end":13998,"line_start":435,"line_end":435,"column_start":1,"column_end":39,"is_primary":false,"text":[{"text":"impl_tensor_op!(Div, div, /, \"divide\");","highlight_start":1,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:300:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m300\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        Tensor::with_shape_f32(new_data, shape1.clone())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m435\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_tensor_op!(Div, div, /, \"divide\");\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_tensor_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m300\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(new_data, shape1.clone(), /* Option<Vec<Tensor>> */)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":10661,"byte_end":10686,"line_start":337,"line_end":337,"column_start":47,"column_end":72,"is_primary":false,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13960,"byte_end":13998,"line_start":435,"line_end":435,"column_start":1,"column_end":39,"is_primary":false,"text":[{"text":"impl_tensor_op!(Div, div, /, \"divide\");","highlight_start":1,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\main.rs","byte_start":10639,"byte_end":10661,"line_start":337,"line_end":337,"column_start":25,"column_end":47,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":25,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13960,"byte_end":13998,"line_start":435,"line_end":435,"column_start":1,"column_end":39,"is_primary":false,"text":[{"text":"impl_tensor_op!(Div, div, /, \"divide\");","highlight_start":1,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":10661,"byte_end":10686,"line_start":337,"line_end":337,"column_start":47,"column_end":72,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":null,"suggested_replacement":"(new_data, shape.clone(), /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":{"span":{"file_name":"src\\main.rs","byte_start":13960,"byte_end":13998,"line_start":435,"line_end":435,"column_start":1,"column_end":39,"is_primary":false,"text":[{"text":"impl_tensor_op!(Div, div, /, \"divide\");","highlight_start":1,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:337:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m337\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        Tensor::with_shape_f32(new_data, shape.clone())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m435\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_tensor_op!(Div, div, /, \"divide\");\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_tensor_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m337\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(new_data, shape.clone(), /* Option<Vec<Tensor>> */)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":11346,"byte_end":11371,"line_start":354,"line_end":354,"column_start":47,"column_end":72,"is_primary":false,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13960,"byte_end":13998,"line_start":435,"line_end":435,"column_start":1,"column_end":39,"is_primary":false,"text":[{"text":"impl_tensor_op!(Div, div, /, \"divide\");","highlight_start":1,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\main.rs","byte_start":11324,"byte_end":11346,"line_start":354,"line_end":354,"column_start":25,"column_end":47,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":25,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13960,"byte_end":13998,"line_start":435,"line_end":435,"column_start":1,"column_end":39,"is_primary":false,"text":[{"text":"impl_tensor_op!(Div, div, /, \"divide\");","highlight_start":1,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":11346,"byte_end":11371,"line_start":354,"line_end":354,"column_start":47,"column_end":72,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":null,"suggested_replacement":"(new_data, shape.clone(), /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":{"span":{"file_name":"src\\main.rs","byte_start":13960,"byte_end":13998,"line_start":435,"line_end":435,"column_start":1,"column_end":39,"is_primary":false,"text":[{"text":"impl_tensor_op!(Div, div, /, \"divide\");","highlight_start":1,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:354:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m354\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        Tensor::with_shape_f32(new_data, shape.clone())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m435\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_tensor_op!(Div, div, /, \"divide\");\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_tensor_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m354\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(new_data, shape.clone(), /* Option<Vec<Tensor>> */)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":12447,"byte_end":12472,"line_start":388,"line_end":388,"column_start":47,"column_end":72,"is_primary":false,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13960,"byte_end":13998,"line_start":435,"line_end":435,"column_start":1,"column_end":39,"is_primary":false,"text":[{"text":"impl_tensor_op!(Div, div, /, \"divide\");","highlight_start":1,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\main.rs","byte_start":12425,"byte_end":12447,"line_start":388,"line_end":388,"column_start":25,"column_end":47,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":25,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13960,"byte_end":13998,"line_start":435,"line_end":435,"column_start":1,"column_end":39,"is_primary":false,"text":[{"text":"impl_tensor_op!(Div, div, /, \"divide\");","highlight_start":1,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":12447,"byte_end":12472,"line_start":388,"line_end":388,"column_start":47,"column_end":72,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":null,"suggested_replacement":"(new_data, shape.clone(), /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":{"span":{"file_name":"src\\main.rs","byte_start":13960,"byte_end":13998,"line_start":435,"line_end":435,"column_start":1,"column_end":39,"is_primary":false,"text":[{"text":"impl_tensor_op!(Div, div, /, \"divide\");","highlight_start":1,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:388:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m388\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        Tensor::with_shape_f32(new_data, shape.clone())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m435\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_tensor_op!(Div, div, /, \"divide\");\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_tensor_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m388\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(new_data, shape.clone(), /* Option<Vec<Tensor>> */)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":13134,"byte_end":13159,"line_start":405,"line_end":405,"column_start":47,"column_end":72,"is_primary":false,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13960,"byte_end":13998,"line_start":435,"line_end":435,"column_start":1,"column_end":39,"is_primary":false,"text":[{"text":"impl_tensor_op!(Div, div, /, \"divide\");","highlight_start":1,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\main.rs","byte_start":13112,"byte_end":13134,"line_start":405,"line_end":405,"column_start":25,"column_end":47,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":25,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":13960,"byte_end":13998,"line_start":435,"line_end":435,"column_start":1,"column_end":39,"is_primary":false,"text":[{"text":"impl_tensor_op!(Div, div, /, \"divide\");","highlight_start":1,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":13134,"byte_end":13159,"line_start":405,"line_end":405,"column_start":47,"column_end":72,"is_primary":true,"text":[{"text":"                        Tensor::with_shape_f32(new_data, shape.clone())","highlight_start":47,"highlight_end":72}],"label":null,"suggested_replacement":"(new_data, shape.clone(), /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":{"span":{"file_name":"src\\main.rs","byte_start":13960,"byte_end":13998,"line_start":435,"line_end":435,"column_start":1,"column_end":39,"is_primary":false,"text":[{"text":"impl_tensor_op!(Div, div, /, \"divide\");","highlight_start":1,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_tensor_op!","def_site_span":{"file_name":"src\\main.rs","byte_start":8308,"byte_end":8335,"line_start":279,"line_end":279,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! impl_tensor_op {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:405:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m405\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        Tensor::with_shape_f32(new_data, shape.clone())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m435\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_tensor_op!(Div, div, /, \"divide\");\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_tensor_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m405\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(new_data, shape.clone(), /* Option<Vec<Tensor>> */)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":14052,"byte_end":14156,"line_start":438,"line_end":441,"column_start":40,"column_end":6,"is_primary":false,"text":[{"text":"    let tensor = Tensor::with_shape_f32(","highlight_start":40,"highlight_end":41},{"text":"        vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0],","highlight_start":1,"highlight_end":74},{"text":"        vec![2, 3, 2],","highlight_start":1,"highlight_end":23},{"text":"    );","highlight_start":1,"highlight_end":6}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":14030,"byte_end":14052,"line_start":438,"line_end":438,"column_start":18,"column_end":40,"is_primary":true,"text":[{"text":"    let tensor = Tensor::with_shape_f32(","highlight_start":18,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":14052,"byte_end":14156,"line_start":438,"line_end":441,"column_start":40,"column_end":6,"is_primary":true,"text":[{"text":"    let tensor = Tensor::with_shape_f32(","highlight_start":40,"highlight_end":41},{"text":"        vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0],","highlight_start":1,"highlight_end":74},{"text":"        vec![2, 3, 2],","highlight_start":1,"highlight_end":23},{"text":"    );","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":"(vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0], vec![2, 3, 2], /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:438:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m438\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    let tensor = Tensor::with_shape_f32(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m __________________\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m439\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0],\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m440\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        vec![2, 3, 2],\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m441\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|_____-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m438\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    let tensor = Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0], vec![2, 3, 2], /* Option<Vec<Tensor>> */)\u001b[0m\u001b[0m;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":14198,"byte_end":14302,"line_start":442,"line_end":445,"column_start":41,"column_end":6,"is_primary":false,"text":[{"text":"    let tensor2 = Tensor::with_shape_f32(","highlight_start":41,"highlight_end":42},{"text":"        vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0],","highlight_start":1,"highlight_end":74},{"text":"        vec![2, 3, 2],","highlight_start":1,"highlight_end":23},{"text":"    );","highlight_start":1,"highlight_end":6}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":14176,"byte_end":14198,"line_start":442,"line_end":442,"column_start":19,"column_end":41,"is_primary":true,"text":[{"text":"    let tensor2 = Tensor::with_shape_f32(","highlight_start":19,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":14198,"byte_end":14302,"line_start":442,"line_end":445,"column_start":41,"column_end":6,"is_primary":true,"text":[{"text":"    let tensor2 = Tensor::with_shape_f32(","highlight_start":41,"highlight_end":42},{"text":"        vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0],","highlight_start":1,"highlight_end":74},{"text":"        vec![2, 3, 2],","highlight_start":1,"highlight_end":23},{"text":"    );","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":"(vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0], vec![2, 3, 2], /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:442:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m442\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    let tensor2 = Tensor::with_shape_f32(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m ___________________\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m443\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0],\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m444\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        vec![2, 3, 2],\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m445\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|_____-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m442\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    let tensor2 = Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0], vec![2, 3, 2], /* Option<Vec<Tensor>> */)\u001b[0m\u001b[0m;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                         \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":14454,"byte_end":14492,"line_start":454,"line_end":454,"column_start":40,"column_end":78,"is_primary":false,"text":[{"text":"        let t1 = Tensor::with_shape_f32(vec![1.0, 2.0, 3.0, 4.0], vec![2, 2]);","highlight_start":40,"highlight_end":78}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":14432,"byte_end":14454,"line_start":454,"line_end":454,"column_start":18,"column_end":40,"is_primary":true,"text":[{"text":"        let t1 = Tensor::with_shape_f32(vec![1.0, 2.0, 3.0, 4.0], vec![2, 2]);","highlight_start":18,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":14454,"byte_end":14492,"line_start":454,"line_end":454,"column_start":40,"column_end":78,"is_primary":true,"text":[{"text":"        let t1 = Tensor::with_shape_f32(vec![1.0, 2.0, 3.0, 4.0], vec![2, 2]);","highlight_start":40,"highlight_end":78}],"label":null,"suggested_replacement":"(vec![1.0, 2.0, 3.0, 4.0], vec![2, 2], /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:454:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m454\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let t1 = Tensor::with_shape_f32(vec![1.0, 2.0, 3.0, 4.0], vec![2, 2]);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m454\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        let t1 = Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(vec![1.0, 2.0, 3.0, 4.0], vec![2, 2], /* Option<Vec<Tensor>> */)\u001b[0m\u001b[0m;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":14533,"byte_end":14571,"line_start":455,"line_end":455,"column_start":40,"column_end":78,"is_primary":false,"text":[{"text":"        let t2 = Tensor::with_shape_f32(vec![5.0, 6.0, 7.0, 8.0], vec![2, 2]);","highlight_start":40,"highlight_end":78}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":14511,"byte_end":14533,"line_start":455,"line_end":455,"column_start":18,"column_end":40,"is_primary":true,"text":[{"text":"        let t2 = Tensor::with_shape_f32(vec![5.0, 6.0, 7.0, 8.0], vec![2, 2]);","highlight_start":18,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":14533,"byte_end":14571,"line_start":455,"line_end":455,"column_start":40,"column_end":78,"is_primary":true,"text":[{"text":"        let t2 = Tensor::with_shape_f32(vec![5.0, 6.0, 7.0, 8.0], vec![2, 2]);","highlight_start":40,"highlight_end":78}],"label":null,"suggested_replacement":"(vec![5.0, 6.0, 7.0, 8.0], vec![2, 2], /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:455:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m455\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let t2 = Tensor::with_shape_f32(vec![5.0, 6.0, 7.0, 8.0], vec![2, 2]);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m455\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        let t2 = Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(vec![5.0, 6.0, 7.0, 8.0], vec![2, 2], /* Option<Vec<Tensor>> */)\u001b[0m\u001b[0m;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":15216,"byte_end":15254,"line_start":476,"line_end":476,"column_start":40,"column_end":78,"is_primary":false,"text":[{"text":"        let t1 = Tensor::with_shape_f32(vec![1.0, 2.0, 3.0, 4.0], vec![2, 2]);","highlight_start":40,"highlight_end":78}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":15194,"byte_end":15216,"line_start":476,"line_end":476,"column_start":18,"column_end":40,"is_primary":true,"text":[{"text":"        let t1 = Tensor::with_shape_f32(vec![1.0, 2.0, 3.0, 4.0], vec![2, 2]);","highlight_start":18,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":15216,"byte_end":15254,"line_start":476,"line_end":476,"column_start":40,"column_end":78,"is_primary":true,"text":[{"text":"        let t1 = Tensor::with_shape_f32(vec![1.0, 2.0, 3.0, 4.0], vec![2, 2]);","highlight_start":40,"highlight_end":78}],"label":null,"suggested_replacement":"(vec![1.0, 2.0, 3.0, 4.0], vec![2, 2], /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:476:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m476\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let t1 = Tensor::with_shape_f32(vec![1.0, 2.0, 3.0, 4.0], vec![2, 2]);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m476\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        let t1 = Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(vec![1.0, 2.0, 3.0, 4.0], vec![2, 2], /* Option<Vec<Tensor>> */)\u001b[0m\u001b[0m;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":15295,"byte_end":15333,"line_start":477,"line_end":477,"column_start":40,"column_end":78,"is_primary":false,"text":[{"text":"        let t2 = Tensor::with_shape_f32(vec![5.0, 6.0, 7.0, 8.0], vec![2, 2]);","highlight_start":40,"highlight_end":78}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":15273,"byte_end":15295,"line_start":477,"line_end":477,"column_start":18,"column_end":40,"is_primary":true,"text":[{"text":"        let t2 = Tensor::with_shape_f32(vec![5.0, 6.0, 7.0, 8.0], vec![2, 2]);","highlight_start":18,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":15295,"byte_end":15333,"line_start":477,"line_end":477,"column_start":40,"column_end":78,"is_primary":true,"text":[{"text":"        let t2 = Tensor::with_shape_f32(vec![5.0, 6.0, 7.0, 8.0], vec![2, 2]);","highlight_start":40,"highlight_end":78}],"label":null,"suggested_replacement":"(vec![5.0, 6.0, 7.0, 8.0], vec![2, 2], /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:477:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m477\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let t2 = Tensor::with_shape_f32(vec![5.0, 6.0, 7.0, 8.0], vec![2, 2]);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m477\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        let t2 = Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(vec![5.0, 6.0, 7.0, 8.0], vec![2, 2], /* Option<Vec<Tensor>> */)\u001b[0m\u001b[0m;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":15969,"byte_end":16007,"line_start":498,"line_end":498,"column_start":40,"column_end":78,"is_primary":false,"text":[{"text":"        let t1 = Tensor::with_shape_f32(vec![1.0, 2.0, 3.0, 4.0], vec![2, 2]);","highlight_start":40,"highlight_end":78}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":15947,"byte_end":15969,"line_start":498,"line_end":498,"column_start":18,"column_end":40,"is_primary":true,"text":[{"text":"        let t1 = Tensor::with_shape_f32(vec![1.0, 2.0, 3.0, 4.0], vec![2, 2]);","highlight_start":18,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":15969,"byte_end":16007,"line_start":498,"line_end":498,"column_start":40,"column_end":78,"is_primary":true,"text":[{"text":"        let t1 = Tensor::with_shape_f32(vec![1.0, 2.0, 3.0, 4.0], vec![2, 2]);","highlight_start":40,"highlight_end":78}],"label":null,"suggested_replacement":"(vec![1.0, 2.0, 3.0, 4.0], vec![2, 2], /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:498:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m498\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let t1 = Tensor::with_shape_f32(vec![1.0, 2.0, 3.0, 4.0], vec![2, 2]);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m498\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        let t1 = Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(vec![1.0, 2.0, 3.0, 4.0], vec![2, 2], /* Option<Vec<Tensor>> */)\u001b[0m\u001b[0m;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":16048,"byte_end":16086,"line_start":499,"line_end":499,"column_start":40,"column_end":78,"is_primary":false,"text":[{"text":"        let t2 = Tensor::with_shape_f32(vec![5.0, 6.0, 7.0, 8.0], vec![2, 2]);","highlight_start":40,"highlight_end":78}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":16026,"byte_end":16048,"line_start":499,"line_end":499,"column_start":18,"column_end":40,"is_primary":true,"text":[{"text":"        let t2 = Tensor::with_shape_f32(vec![5.0, 6.0, 7.0, 8.0], vec![2, 2]);","highlight_start":18,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":16048,"byte_end":16086,"line_start":499,"line_end":499,"column_start":40,"column_end":78,"is_primary":true,"text":[{"text":"        let t2 = Tensor::with_shape_f32(vec![5.0, 6.0, 7.0, 8.0], vec![2, 2]);","highlight_start":40,"highlight_end":78}],"label":null,"suggested_replacement":"(vec![5.0, 6.0, 7.0, 8.0], vec![2, 2], /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:499:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m499\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let t2 = Tensor::with_shape_f32(vec![5.0, 6.0, 7.0, 8.0], vec![2, 2]);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m499\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        let t2 = Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(vec![5.0, 6.0, 7.0, 8.0], vec![2, 2], /* Option<Vec<Tensor>> */)\u001b[0m\u001b[0m;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":16764,"byte_end":16825,"line_start":521,"line_end":521,"column_start":35,"column_end":96,"is_primary":false,"text":[{"text":"            Tensor::with_shape_f32(vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0], vec![2, 2, 2]);","highlight_start":35,"highlight_end":96}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":16742,"byte_end":16764,"line_start":521,"line_end":521,"column_start":13,"column_end":35,"is_primary":true,"text":[{"text":"            Tensor::with_shape_f32(vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0], vec![2, 2, 2]);","highlight_start":13,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":16764,"byte_end":16825,"line_start":521,"line_end":521,"column_start":35,"column_end":96,"is_primary":true,"text":[{"text":"            Tensor::with_shape_f32(vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0], vec![2, 2, 2]);","highlight_start":35,"highlight_end":96}],"label":null,"suggested_replacement":"(vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0], vec![2, 2, 2], /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:521:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m521\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Tensor::with_shape_f32(vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0], vec![2, 2, 2]);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m521\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m            Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0], vec![2, 2, 2], /* Option<Vec<Tensor>> */)\u001b[0m\u001b[0m;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":16866,"byte_end":16969,"line_start":522,"line_end":525,"column_start":40,"column_end":10,"is_primary":false,"text":[{"text":"        let t2 = Tensor::with_shape_f32(","highlight_start":40,"highlight_end":41},{"text":"            vec![9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0],","highlight_start":1,"highlight_end":65},{"text":"            vec![2, 2, 2],","highlight_start":1,"highlight_end":27},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":"argument #3 of type `Option<Vec<Tensor>>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":16844,"byte_end":16866,"line_start":522,"line_end":522,"column_start":18,"column_end":40,"is_primary":true,"text":[{"text":"        let t2 = Tensor::with_shape_f32(","highlight_start":18,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":4488,"byte_end":4502,"line_start":187,"line_end":187,"column_start":23,"column_end":37,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":23,"highlight_end":37}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4504,"byte_end":4521,"line_start":187,"line_end":187,"column_start":39,"column_end":56,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":39,"highlight_end":56}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4549,"line_start":187,"line_end":187,"column_start":58,"column_end":84,"is_primary":false,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":84}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":4473,"byte_end":4487,"line_start":187,"line_end":187,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":16866,"byte_end":16969,"line_start":522,"line_end":525,"column_start":40,"column_end":10,"is_primary":true,"text":[{"text":"        let t2 = Tensor::with_shape_f32(","highlight_start":40,"highlight_end":41},{"text":"            vec![9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0],","highlight_start":1,"highlight_end":65},{"text":"            vec![2, 2, 2],","highlight_start":1,"highlight_end":27},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"(vec![9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0], vec![2, 2, 2], /* Option<Vec<Tensor>> */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: this function takes 3 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:522:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m522\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let t2 = Tensor::with_shape_f32(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m __________________\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m523\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            vec![9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0],\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m524\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            vec![2, 2, 2],\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m525\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|_________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument #3 of type `Option<Vec<Tensor>>` is missing\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m522\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        let t2 = Tensor::with_shape_f32\u001b[0m\u001b[0m\u001b[38;5;10m(vec![9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0], vec![2, 2, 2], /* Option<Vec<Tensor>> */)\u001b[0m\u001b[0m;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `graph`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src\\main.rs","byte_start":1951,"byte_end":1956,"line_start":94,"line_end":94,"column_start":40,"column_end":45,"is_primary":true,"text":[{"text":"            Tensor::F32 { data, shape, graph } => {","highlight_start":40,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"try ignoring the field","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":1951,"byte_end":1956,"line_start":94,"line_end":94,"column_start":40,"column_end":45,"is_primary":true,"text":[{"text":"            Tensor::F32 { data, shape, graph } => {","highlight_start":40,"highlight_end":45}],"label":null,"suggested_replacement":"graph: _","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused variable: `graph`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:94:40\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m94\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Tensor::F32 { data, shape, graph } => {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11mhelp: try ignoring the field: `graph: _`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: `#[warn(unused_variables)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `graph`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4528,"line_start":187,"line_end":187,"column_start":58,"column_end":63,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":63}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":4523,"byte_end":4528,"line_start":187,"line_end":187,"column_start":58,"column_end":63,"is_primary":true,"text":[{"text":"    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {","highlight_start":58,"highlight_end":63}],"label":null,"suggested_replacement":"_graph","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused variable: `graph`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:187:58\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn with_shape_f32(data: Vec<f32>, shape: Vec<usize>, graph: Option<Vec<Tensor>>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11mhelp: if this is intentional, prefix it with an underscore: `_graph`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 35 previous errors; 2 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: aborting due to 35 previous errors; 2 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0061, E0412, E0433.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mSome errors have detailed explanations: E0061, E0412, E0433.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0061`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mFor more information about an error, try `rustc --explain E0061`.\u001b[0m\n"}
